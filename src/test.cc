#include "cm256/cm256.h"
#include "cm256/gf256.h"
#include <iostream>

using std::cout;
using std::endl;
bool ExampleFileUsage()
{
    if (cm256_init())
    {
        return false;
    }

    cm256_encoder_params params;

    // Number of bytes per file block
    params.BlockBytes = 1296;

    // Number of blocks
    params.OriginalCount = 100;

    // Number of additional recovery blocks generated by encoder
    params.RecoveryCount = 30;

    // Size of the original file
    static const int OriginalFileBytes = params.OriginalCount * params.BlockBytes;

    // Allocate and fill the original file data
    uint8_t* originalFileData = new uint8_t[OriginalFileBytes];
    for (int i = 0; i < OriginalFileBytes; ++i)
    {
        originalFileData[i] = (uint8_t)i;
    }

    // Pointers to data
    cm256_block blocks[256];
    for (int i = 0; i < params.OriginalCount; ++i)
    {
        blocks[i].Block = originalFileData + i * params.BlockBytes;
        blocks[i].Index = cm256_get_original_block_index(params, i);

    }

    // Recovery data
    uint8_t* recoveryBlocks = new uint8_t[params.RecoveryCount * params.BlockBytes];

    // Generate recovery data
    if (cm256_encode(params, blocks, recoveryBlocks))
    {
        return false;
    }

    // Initialize the indices
    // for (int i = 0; i < params.OriginalCount; ++i)
    // {
    //     blocks[i].Index = cm256_get_original_block_index(params, i);
    // }
    cout << "debug" << endl;
    cout << static_cast<int>(((char*)(blocks[2].Block))[2]) << endl;

    //// Simulate loss of data, substituting a recovery block in its place ////
    for (int i = 0; i < params.RecoveryCount && i < params.OriginalCount; ++i)
    {
        blocks[i].Block = recoveryBlocks + params.BlockBytes * i; // First recovery block
        blocks[i].Index = cm256_get_recovery_block_index(params, i); // First recovery block index
    }
    //// Simulate loss of data, substituting a recovery block in its place ////
    cout << static_cast<int>(((char*)(blocks[2].Block))[2]) << endl;

    if (cm256_decode(params, blocks))
    {
        return false;
    }
    cout << static_cast<int>(((char*)(blocks[2].Block))[2]) << endl;

    for (int i = 0; i < params.RecoveryCount && i < params.OriginalCount; ++i)
    {
        uint8_t* block = (uint8_t*)blocks[i].Block;
        int index = blocks[i].Index;

        for (int j = 0; j < params.BlockBytes; ++j)
        {
            const uint8_t expected = (uint8_t)(j + index * params.BlockBytes);
            if (block[j] != expected)
            {
                return false;
            }
        }
    }

    delete[] originalFileData;
    delete[] recoveryBlocks;

    return true;
}

int main() {
    if (cm256_init()) {
		// Wrong static library
		exit(1);
	}
    ExampleFileUsage();
    // printf("hello\n");
}